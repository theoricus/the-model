// Generated by CoffeeScript 1.6.3
var $, Bind, Event, Model, _, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

_ = require('lodash');

$ = require('../bower_components/jquery/jquery');

Event = require("the-event");

Bind = require('the-bind');

/**
  The Model class is responsible for saving data locally and remotelly requesting web-services.

  @class Model
*/


Model = (function(_super) {
  __extends(Model, _super);

  function Model() {
    this.save = __bind(this.save, this);
    _ref = Model.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  /*
  @property {Bind} A simple data store with on/off switches to watch specefic
  property changing.
  */


  Model.prototype.store = null;

  /*
  @property {Number} Stores the local ID of the object (client id).
  */


  Model.prototype.cid = null;

  /*
  @property {Object} Stores the instances attributes
  */


  Model.prototype.keys = null;

  /*
  @property {Object} ID's key name, it might change to "_id" if the webservices return data from mongodb.
  */


  Model.prototype.id = "id";

  /*
    Responsible for configuring the Models rest URLs, attributes and ID's key name.
  
    @param config {Object} Object containing the REST urls, and the Model attributes.
    @example
      class Todo extends Model
  
        @configure
  
          urls:
            'all':'http://localhost:3000/todos'
            'create':'http://localhost:3000/todos'
            'read':'http://localhost:3000/todos/:id'
            'update':'http://localhost:3000/todos/:id'
            'delete':'http://localhost:3000/todos/:id'
  
          keys:
            "title":String
            "done":Boolean
  
          id:"_id"
  */


  Model.configure = function(config) {
    var i, key, method, type, url, _i, _len, _ref1, _ref2;
    this._config = {
      urls: {},
      keys: {}
    };
    this._records = [];
    this._last_action = null;
    _ref1 = ["create", "read", "update", "delete", "all", "find"];
    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
      method = _ref1[i];
      if ((url = config.urls[method]) != null) {
        this._config.urls[method] = url;
      }
    }
    _ref2 = config.keys;
    for (key in _ref2) {
      type = _ref2[key];
      this._config.keys[key] = type;
    }
    if (config.id) {
      return this.id = config.id;
    }
  };

  Model.prototype._init = function(dict) {
    this.keys = {};
    this.cid = this.constructor._records.length;
    return this.store.set(dict);
  };

  /* 
  
    Global validate method, will perform simple validations for native types
    as well as run custom validations against the given methods in configuration
  
    Validates the attributes values against the 'types' setted in the `@configure` method.
  
    @param key {String} Attribute to be validated
    @param val {String} Value to validate
  */


  Model.prototype.validate = function(key, val) {
    var checker;
    checker = this.constructor._config.keys[key];
    if (/native code/.test(checker)) {
      switch ((("" + checker).match(/function\s(\w+)/))[1]) {
        case 'String':
          return typeof val === 'string';
        case 'Number':
          return typeof val === 'number';
        case 'Boolean':
          return typeof val === 'boolean';
        default:
          return val instanceof checker;
      }
    } else {
      return checker(val);
    }
  };

  /* --------------------------------------------------------------------------
    Getter / Setter
  --------------------------------------------------------------------------
  */


  Model.prototype.get = function(keyumn) {
    return this.keys[keyumn];
  };

  Model.prototype.set = function() {
    var args, dict, key, val;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 1) {
      dict = args[0];
      for (key in dict) {
        val = dict[key];
        if (this.constructor._config.keys[key]) {
          this.store.set(key, val);
        } else if (key !== this.constructor.id) {
          this[key] = val;
        } else if (key === this.constructor.id) {
          this["id"] = val;
        }
      }
      return dict;
    }
    key = args[0];
    val = args[1];
    if (this.validate(key, val)) {
      return this.keys[key] = val;
    } else {
      throw new Error("Invalid type for keyumn '" + key + "' = " + val);
    }
  };

  /* --------------------------------------------------------------------------
    CURD and helpful methods
  --------------------------------------------------------------------------
  */


  Model._create = function(props) {
    var k, keys, record, v;
    keys = {};
    record = new this;
    record.store = new Bind;
    for (k in props) {
      v = props[k];
      if (this._config.keys[k]) {
        keys[k] = v;
      } else {
        record[k] = v;
      }
    }
    if (props[this.id]) {
      keys.id = props[this.id];
    }
    record._init(keys);
    this._records.push(record);
    return record;
  };

  Model.create = function(props, callback) {
    var record, req,
      _this = this;
    this._last_action = "create";
    if (callback == null) {
      record = this._create(props);
      this.emit("create", record);
      this.emit("change", record);
      return record;
    }
    req = this.fetch(this._config.urls.create, 'POST', props);
    req.done(function(data) {
      record = _this._create(data);
      _this.emit("create", record);
      _this.emit("change", record);
      return callback(record, null);
    });
    return req.error(function(error) {
      return callback(null, error);
    });
  };

  Model.read = function(id, callback) {
    var found, req;
    found = (_.find(this._records, {
      id: id
    })) || (_.find(this._records, {
      cid: id
    }));
    if (callback == null) {
      return found;
    }
    req = this.fetch(this._config.urls.read.replace(/(\:\w+)$/, (found != null ? found.id : void 0) || id), 'GET');
    req.done(function(data) {
      var record;
      record = found.update(data) || (this.create(data));
      return callback(record, null);
    });
    return req.error(function(error) {
      return callback(null, error);
    });
  };

  Model.prototype.update = function(keys, callback) {
    var req, url,
      _this = this;
    this.store.set(keys);
    this.constructor._last_action = "update";
    if (callback == null) {
      this.emit("update", this);
      this.emit("change", this);
      return this;
    }
    url = this.constructor._config.urls.update.replace(/(\:\w+)$/, this.id);
    req = this.constructor.fetch(url, 'PUT', keys);
    req.done(function(data) {
      _this.emit("update");
      _this.emit("change");
      return callback(_this, null);
    });
    return req.error(function(error) {
      return callback(null, error);
    });
  };

  Model.prototype["delete"] = function(callback) {
    var i, record, req, url, _i, _len, _ref1,
      _this = this;
    _ref1 = this.constructor._records;
    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
      record = _ref1[i];
      if (record === this) {
        this.constructor._records.splice(i, 1);
      }
    }
    this.constructor._last_action = "delete";
    if (callback == null) {
      this.emit("change", this);
      this.emit("delete", this);
      return true;
    }
    url = this.constructor._config.urls["delete"].replace(/(\:\w+)$/, this.id);
    req = this.constructor.fetch(url, 'DELETE');
    req.done(function(data) {
      _this.emit("change");
      _this.emit("delete");
      return callback(true, null);
    });
    return req.error(function(error) {
      return callback(false, error);
    });
  };

  Model.all = function(callback) {
    var req,
      _this = this;
    if (callback == null) {
      return this._records;
    }
    req = this.fetch(this._config.urls.all, 'GET');
    req.done(function(data) {
      var found, keys, _i, _len, _ref1;
      _ref1 = [].concat(data);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        keys = _ref1[_i];
        found = _.find(_this._records, {
          id: keys[_this.id]
        });
        if (!found) {
          _this.create(keys);
        } else {
          found.update(keys);
        }
      }
      return callback(data, null);
    });
    return req.error(function(error) {
      return callback(null, error);
    });
  };

  Model.find = function(keys) {
    var found;
    if (typeof keys === "object") {
      keys = {
        keys: keys
      };
      return _.where(this._records, keys);
    } else {
      found = _.where(this._records, {
        id: keys
      });
      if (found.length) {
        return found;
      } else {
        return _.where(this._records, {
          cid: keys
        });
      }
    }
  };

  Model.prototype.save = function(callback) {
    var done, error, req, url,
      _this = this;
    done = function(data) {
      return typeof callback === "function" ? callback(data, null) : void 0;
    };
    error = function(error) {
      return typeof callback === "function" ? callback(null, error) : void 0;
    };
    switch (this.constructor._last_action) {
      case "create":
        url = this.constructor._config.urls.create;
        req = this.constructor.fetch(url, 'POST', this.keys);
        req.done(function(data) {
          _this.update(data);
          return done(data);
        });
        return req.error(error);
      case "update":
        url = this.constructor._config.urls.update.replace(/(\:\w+)$/, this.id);
        req = this.constructor.fetch(url, 'PUT', this.keys);
        req.done(done);
        return req.error(error);
      case "delete":
        url = this.constructor._config.urls["delete"].replace(/(\:\w+)$/, this.id);
        req = this.constructor.fetch(url, 'DELETE');
        req.done(done);
        return req.error(error);
    }
  };

  /* --------------------------------------------------------------------------
    Middleware
  --------------------------------------------------------------------------
  */


  Model.fetch = function(url, type, data) {
    var req;
    req = {
      url: url,
      type: type,
      data: data
    };
    req.dataType = 'json';
    return $.ajax(req);
  };

  return Model;

})(Event);

if (exports && module && module.exports) {
  module.exports = Model;
}
